
#include <mcs51/8051.h>
// Last Revision:  October 4, 2009
#include <at89c51ed2.h>  //also includes 8052.h and 8051.h
#include <mcs51reg.h>
//#include <8052.h>   // also included in at89c51ed2.h
#include <stdio.h>
#include <stdlib.h>


void putstr1 (char *s);

volatile int gg;  // global
#include <malloc.h>
#define HEAP_SIZE 0x300

   // size must be smaller than available XRAM
unsigned char  heap[HEAP_SIZE];

char * getstr();
char getchar ();
void putchar (char c);
char data_get[50];


// compiler flags
// -c -mmcs51 --std-sdcc99 --verbose --model-large

// linker flags for C501 with code in SRAM at 0x6000 and data in SRAM at 0xC000
// --code-loc 0x6000 --code-size 0x6000 --xram-loc 0xC000 --xram-size 0x0400 --model-large --out-fmt-ihx

// linker flags for AT89C51RC2 with code in Flash at 0x0000 and data in internal XRAM at 0x0000
// --code-loc 0x0000 --code-size 0x8000 --xram-loc 0x0000 --xram-size 0x400 --model-large --out-fmt-ihx

// linker flags for AT89C51RC2 with code in Flash at 0x0000 and data in internal/external XRAM at 0x0000
// --code-loc 0x0000 --code-size 0x8000 --xram-loc 0x0000 --xram-size 0x8400 --model-large --out-fmt-ihx

// All processor XRAM should be enabled before the call to main().
// This can be done in a user supplied _sdcc_external_startup() function.
// See section 3.11.1 of sdccman.pdf for SDCC revision 2.6.0.




_sdcc_external_startup()
{
    AUXR |= 0x0C;
    TMOD=0x20; //use Timer 1, mode 2
    TH1=0xFA; //4800 baud rate
    SCON=0x50;
    TR1=1;
    TI=1;
    return 0;
}

char getchar ()
{
//	char cc;
//    while (!RI);                // compare asm code generated for these three lines
//    while ((SCON & 0x01) == 0);  // wait for character to be received, spin on RI
	while (RI == 0);
	RI = 0;			// clear RI flag
	return SBUF;  	// return character from SBUF
}

void putchar (char c)
{
//	while (!TI);				// compare asm code generated for these three lines
	while (TI == 0);
//	while ((SCON & 0x02) == 0);    // wait for TX ready, spin on TI
	SBUF = c;  	// load serial port with transmit value
	TI = 0;  	// clear TI flag
}

char * getstr()
{
	char *s=0;
	char c;
	int i=0;
	c = getchar();
	while( c !='\r' && c !='\0')
	{
		//(*(s+i)) = c;
		data_get[i]=c;
		//putchar1(data_get[i]);
		//putchar(data_get[i]);
		i++;
		c = getchar();
	}
	//*(s+i)='\0';
	 data_get[i]='\0';
	//putstr1(data_get);
	//putstr1(data_get);
	s=data_get;
	*(s+i)='\0';
	//putstr1(s);
	return s;
}

void putstr1 (char *s)
{
	int i = 0;
	while (*(s+i)!='\0')
		{			// output characters until NULL found
		putchar(*(s+i));
		i++;
	}

	//putchar1(*s);
	//putchar('\n');
	//return i+1;
}

int size_cal()
{
    char *size1;
    unsigned int i,result=0;
    i=0;
    size1= getstr();
	putstr1(size1);
	while(*(size1+i)!='\0')
    {
      result = (result * 10) + ( *(size1+i)- '0' );
      i++;
    }
    printf("\nnum value is %d",result);
    return result;
}

void main()
{
	 unsigned int res=0,k=0,l=0;
     xdata char * buffer[50];
    unsigned char zz=0;
    unsigned int pp=0;
    unsigned int ff=0;


    init_dynamic_memory((MEMHEADER xdata *)heap, HEAP_SIZE);


	printf("Enter the buffer size between 32 and 2400\n\r");
//	printf_small("Enter the buffer size between 32 and 2400 bytes");

	res=size_cal();
//	zz = 1;
        do
        {
         if (res>2400||res<32||res%8!=0)
         {
        printf_tiny("Enter a valid input\n");
        res=size_cal();
         }
         else
         {
             break;
         }
        }while (res>2400||res<32||res%8!=0);

    do{

        if((buffer[0]=malloc((unsigned int)(res)))==0)
        printf_tiny("malloc buffer0 failed\n\r");

        if((buffer[1]=malloc((unsigned int)(res)))==0)
        {
          printf_tiny("malloc buffer1 failed\n\r");
          free(buffer[0]);
        }
    } while((buffer[0]==0)||(buffer[1]==0));

    printf_tiny("Allocation Successful\n\r");


  do{
    printf_tiny("Enter Characters\n\r");

    zz=getchar();
    putchar(zz);
    switch(zz)
    {
     case '+':
     printf_tiny("Enter a buffer size between 20 and 400\n\r");
     pp= size_cal();

     do
     {
     if(pp>400||pp<20)
      {
          printf_tiny("Ender a valid input\n");
          pp= size_cal();
      }
     }while(pp>400||pp<20);

     if((buffer[k+2]=malloc((unsigned int)(pp)))==0)
     {
         printf_tiny("Malloc allocation failed for buffer[%d]",k+2);
     }
       printf_tiny("Malloc allocation successful for buffer[%d]",k+2);
       k++;
       break;
     case '-':
        printf_tiny("Enter a buffer number to be freed\n");
        ff=size_cal();
        do
        {  if((ff==0)||(ff>k+1))
          {
         printf_tiny("Enter a number other than 0\n");
         ff=size_cal();
          }
         else
         {
           free(buffer[ff]);
           printf_tiny("Buffer[%d] freed successfully\n",ff);
           
           break;
         }
        } while ((ff==0)||(ff>k+1));
    }
  } while ((zz=='+')||(zz=='-')||(zz=='?')||(zz=='@')||(zz=='='));


}







